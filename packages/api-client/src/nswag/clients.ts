/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.5.0 (NJsonSchema v10.6.6.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class AuthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Login For Access Token
     * @return Successful Response
     */
    login(body: Body_login_for_access_token_api_v1_auth_login_post): Promise<Token> {
        let url_ = this.baseUrl + "/api/v1/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = Object.keys(body as any).map((key) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent((body as any)[key]);
        }).join('&')

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<Token> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Token>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : <ErrorMessage>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ErrorMessage>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Token>(<any>null);
    }
}

export class UserClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Me
     * @param body (optional) 
     * @return Successful Response
     */
    me(body: Settings | undefined): Promise<UserInfo> {
        let url_ = this.baseUrl + "/api/v1/user/me";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMe(_response);
        });
    }

    protected processMe(response: Response): Promise<UserInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserInfo>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserInfo>(<any>null);
    }

    /**
     * Create User
     * @return Successful Response
     */
    create(body: Body_create_user_api_v1_user_create_post): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/user/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * Reset Password
     * @param body (optional) 
     * @return Successful Response
     */
    reset_password(username: string, body: Settings | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/user/reset_password?";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined and cannot be null.");
        else
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReset_password(_response);
        });
    }

    protected processReset_password(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }
}

export class V1Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Fetch Key Ceremony Guardian
     * @return Successful Response
     */
    guardianGet(key_name: string, guardian_id: string): Promise<GuardianQueryResponse> {
        let url_ = this.baseUrl + "/api/v1/guardian?";
        if (key_name === undefined || key_name === null)
            throw new Error("The parameter 'key_name' must be defined and cannot be null.");
        else
            url_ += "key_name=" + encodeURIComponent("" + key_name) + "&";
        if (guardian_id === undefined || guardian_id === null)
            throw new Error("The parameter 'guardian_id' must be defined and cannot be null.");
        else
            url_ += "guardian_id=" + encodeURIComponent("" + guardian_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGuardianGet(_response);
        });
    }

    protected processGuardianGet(response: Response): Promise<GuardianQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GuardianQueryResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GuardianQueryResponse>(<any>null);
    }

    /**
     * Create Key Ceremony Guardian
     * @return Successful Response
     */
    guardianPut(body: KeyCeremonyGuardian): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/guardian";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGuardianPut(_response);
        });
    }

    protected processGuardianPut(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }

    /**
     * Update Key Ceremony Guardian
     * @return Successful Response
     */
    guardianPost(body: KeyCeremonyGuardian): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/guardian";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGuardianPost(_response);
        });
    }

    protected processGuardianPost(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }

    /**
     * Fetch Election
     * @return Successful Response
     */
    electionGet(election_id: string): Promise<ElectionQueryResponse> {
        let url_ = this.baseUrl + "/api/v1/election?";
        if (election_id === undefined || election_id === null)
            throw new Error("The parameter 'election_id' must be defined and cannot be null.");
        else
            url_ += "election_id=" + encodeURIComponent("" + election_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processElectionGet(_response);
        });
    }

    protected processElectionGet(response: Response): Promise<ElectionQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ElectionQueryResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ElectionQueryResponse>(<any>null);
    }

    /**
     * Create Election
     * @return Successful Response
     */
    electionPut(body: SubmitElectionRequest): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/election";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processElectionPut(_response);
        });
    }

    protected processElectionPut(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }

    /**
     * Fetch Manifest
     * @return Successful Response
     */
    manifestGet(manifest_hash: string): Promise<ManifestQueryResponse> {
        let url_ = this.baseUrl + "/api/v1/manifest?";
        if (manifest_hash === undefined || manifest_hash === null)
            throw new Error("The parameter 'manifest_hash' must be defined and cannot be null.");
        else
            url_ += "manifest_hash=" + encodeURIComponent("" + manifest_hash) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processManifestGet(_response);
        });
    }

    protected processManifestGet(response: Response): Promise<ManifestQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ManifestQueryResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ManifestQueryResponse>(<any>null);
    }

    /**
     * Submit Manifest
     * @return Successful Response
     */
    manifestPut(body: ValidateManifestRequest): Promise<ManifestSubmitResponse> {
        let url_ = this.baseUrl + "/api/v1/manifest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processManifestPut(_response);
        });
    }

    protected processManifestPut(response: Response): Promise<ManifestSubmitResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            result202 = _responseText === "" ? null : <ManifestSubmitResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result202;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ManifestSubmitResponse>(<any>null);
    }

    /**
     * Fetch Ballot
     * @return Successful Response
     */
    ballot(election_id: string, ballot_id: string): Promise<BallotQueryResponse> {
        let url_ = this.baseUrl + "/api/v1/ballot?";
        if (election_id === undefined || election_id === null)
            throw new Error("The parameter 'election_id' must be defined and cannot be null.");
        else
            url_ += "election_id=" + encodeURIComponent("" + election_id) + "&";
        if (ballot_id === undefined || ballot_id === null)
            throw new Error("The parameter 'ballot_id' must be defined and cannot be null.");
        else
            url_ += "ballot_id=" + encodeURIComponent("" + ballot_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBallot(_response);
        });
    }

    protected processBallot(response: Response): Promise<BallotQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BallotQueryResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BallotQueryResponse>(<any>null);
    }

    /**
     * Fetch Ciphertext Tally
     * @return Successful Response
     */
    tallyGet(election_id: string, tally_name: string): Promise<CiphertextTally> {
        let url_ = this.baseUrl + "/api/v1/tally?";
        if (election_id === undefined || election_id === null)
            throw new Error("The parameter 'election_id' must be defined and cannot be null.");
        else
            url_ += "election_id=" + encodeURIComponent("" + election_id) + "&";
        if (tally_name === undefined || tally_name === null)
            throw new Error("The parameter 'tally_name' must be defined and cannot be null.");
        else
            url_ += "tally_name=" + encodeURIComponent("" + tally_name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTallyGet(_response);
        });
    }

    protected processTallyGet(response: Response): Promise<CiphertextTally> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CiphertextTally>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CiphertextTally>(<any>null);
    }

    /**
     * Tally Ballots
     * @return Successful Response
     */
    tallyPost(election_id: string, tally_name: string): Promise<CiphertextTally> {
        let url_ = this.baseUrl + "/api/v1/tally?";
        if (election_id === undefined || election_id === null)
            throw new Error("The parameter 'election_id' must be defined and cannot be null.");
        else
            url_ += "election_id=" + encodeURIComponent("" + election_id) + "&";
        if (tally_name === undefined || tally_name === null)
            throw new Error("The parameter 'tally_name' must be defined and cannot be null.");
        else
            url_ += "tally_name=" + encodeURIComponent("" + tally_name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTallyPost(_response);
        });
    }

    protected processTallyPost(response: Response): Promise<CiphertextTally> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CiphertextTally>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CiphertextTally>(<any>null);
    }

    /**
     * Ping
     * @return Successful Response
     */
    ping(): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/ping";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPing(_response);
        });
    }

    protected processPing(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }
}

export class GuardianClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Find Key Ceremony Guardians
     * @param skip (optional) 
     * @param limit (optional) 
     * @return Successful Response
     */
    find(skip: number | undefined, limit: number | undefined, body: BaseQueryRequest): Promise<GuardianQueryResponse> {
        let url_ = this.baseUrl + "/api/v1/guardian/find?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFind(_response);
        });
    }

    protected processFind(response: Response): Promise<GuardianQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GuardianQueryResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GuardianQueryResponse>(<any>null);
    }

    /**
     * Announce Guardian
     * @return Successful Response
     */
    announce(body: GuardianAnnounceRequest): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/key/guardian/announce";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnnounce(_response);
        });
    }

    protected processAnnounce(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }

    /**
     * Share Backups
     * @return Successful Response
     */
    backup(body: GuardianSubmitBackupRequest): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/key/guardian/backup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBackup(_response);
        });
    }

    protected processBackup(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }

    /**
     * Verify Backups
     * @return Successful Response
     */
    verify(body: GuardianSubmitVerificationRequest): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/key/guardian/verify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processVerify(_response);
        });
    }

    protected processVerify(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }

    /**
     * Challenge Backups
     * @return Successful Response
     */
    challenge(body: GuardianSubmitChallengeRequest): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/key/guardian/challenge";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChallenge(_response);
        });
    }

    protected processChallenge(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }
}

export class KeyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Fetch Ceremony
     * @return Successful Response
     */
    ceremonyGet(key_name: string): Promise<KeyCeremonyQueryResponse> {
        let url_ = this.baseUrl + "/api/v1/key/ceremony?";
        if (key_name === undefined || key_name === null)
            throw new Error("The parameter 'key_name' must be defined and cannot be null.");
        else
            url_ += "key_name=" + encodeURIComponent("" + key_name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCeremonyGet(_response);
        });
    }

    protected processCeremonyGet(response: Response): Promise<KeyCeremonyQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <KeyCeremonyQueryResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KeyCeremonyQueryResponse>(<any>null);
    }

    /**
     * Create Ceremony
     * @return Successful Response
     */
    ceremonyPut(body: KeyCeremonyCreateRequest): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/key/ceremony";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCeremonyPut(_response);
        });
    }

    protected processCeremonyPut(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }
}

export class CeremonyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Fetch Ceremony State
     * @return Successful Response
     */
    state(key_name: string): Promise<KeyCeremonyStateResponse> {
        let url_ = this.baseUrl + "/api/v1/key/ceremony/state?";
        if (key_name === undefined || key_name === null)
            throw new Error("The parameter 'key_name' must be defined and cannot be null.");
        else
            url_ += "key_name=" + encodeURIComponent("" + key_name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processState(_response);
        });
    }

    protected processState(response: Response): Promise<KeyCeremonyStateResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <KeyCeremonyStateResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KeyCeremonyStateResponse>(<any>null);
    }

    /**
     * Find Ceremonies
     * @param skip (optional) 
     * @param limit (optional) 
     * @return Successful Response
     */
    find(skip: number | undefined, limit: number | undefined, body: BaseQueryRequest): Promise<KeyCeremonyQueryResponse> {
        let url_ = this.baseUrl + "/api/v1/key/ceremony/find?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFind(_response);
        });
    }

    protected processFind(response: Response): Promise<KeyCeremonyQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <KeyCeremonyQueryResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KeyCeremonyQueryResponse>(<any>null);
    }

    /**
     * Open Ceremony
     * @return Successful Response
     */
    open(key_name: string): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/key/ceremony/open?";
        if (key_name === undefined || key_name === null)
            throw new Error("The parameter 'key_name' must be defined and cannot be null.");
        else
            url_ += "key_name=" + encodeURIComponent("" + key_name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOpen(_response);
        });
    }

    protected processOpen(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }

    /**
     * Close Ceremony
     * @return Successful Response
     */
    close(key_name: string): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/key/ceremony/close?";
        if (key_name === undefined || key_name === null)
            throw new Error("The parameter 'key_name' must be defined and cannot be null.");
        else
            url_ += "key_name=" + encodeURIComponent("" + key_name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClose(_response);
        });
    }

    protected processClose(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }

    /**
     * Challenge Ceremony
     * @return Successful Response
     */
    challenge(key_name: string): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/key/ceremony/challenge?";
        if (key_name === undefined || key_name === null)
            throw new Error("The parameter 'key_name' must be defined and cannot be null.");
        else
            url_ += "key_name=" + encodeURIComponent("" + key_name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChallenge(_response);
        });
    }

    protected processChallenge(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }

    /**
     * Cancel Ceremony
     * @return Successful Response
     */
    cancel(key_name: string): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/key/ceremony/cancel?";
        if (key_name === undefined || key_name === null)
            throw new Error("The parameter 'key_name' must be defined and cannot be null.");
        else
            url_ += "key_name=" + encodeURIComponent("" + key_name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancel(_response);
        });
    }

    protected processCancel(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }

    /**
     * Fetch Joint Key
     * @return Successful Response
     */
    joint_key(key_name: string): Promise<ElectionJointKeyResponse> {
        let url_ = this.baseUrl + "/api/v1/key/ceremony/joint_key?";
        if (key_name === undefined || key_name === null)
            throw new Error("The parameter 'key_name' must be defined and cannot be null.");
        else
            url_ += "key_name=" + encodeURIComponent("" + key_name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processJoint_key(_response);
        });
    }

    protected processJoint_key(response: Response): Promise<ElectionJointKeyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ElectionJointKeyResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ElectionJointKeyResponse>(<any>null);
    }

    /**
     * Combine Election Keys
     * @return Successful Response
     */
    combine(body: PublishElectionJointKeyRequest): Promise<ElectionJointKeyResponse> {
        let url_ = this.baseUrl + "/api/v1/key/ceremony/combine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCombine(_response);
        });
    }

    protected processCombine(response: Response): Promise<ElectionJointKeyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ElectionJointKeyResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ElectionJointKeyResponse>(<any>null);
    }

    /**
     * Publish Joint Key
     * @return Successful Response
     */
    publish(key_name: string): Promise<ElectionJointKeyResponse> {
        let url_ = this.baseUrl + "/api/v1/key/ceremony/publish?";
        if (key_name === undefined || key_name === null)
            throw new Error("The parameter 'key_name' must be defined and cannot be null.");
        else
            url_ += "key_name=" + encodeURIComponent("" + key_name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: Response): Promise<ElectionJointKeyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ElectionJointKeyResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ElectionJointKeyResponse>(<any>null);
    }
}

export class ChallengeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Verify Ceremony Challenges
     * @return Successful Response
     */
    verify(key_name: string): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/key/ceremony/challenge/verify?";
        if (key_name === undefined || key_name === null)
            throw new Error("The parameter 'key_name' must be defined and cannot be null.");
        else
            url_ += "key_name=" + encodeURIComponent("" + key_name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processVerify(_response);
        });
    }

    protected processVerify(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }
}

export class ElectionClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get Election Constants
     * @return Successful Response
     */
    constants(): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/election/constants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConstants(_response);
        });
    }

    protected processConstants(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * Find Elections
     * @param skip (optional) 
     * @param limit (optional) 
     * @return Successful Response
     */
    find(skip: number | undefined, limit: number | undefined, body: ElectionQueryRequest): Promise<ElectionQueryResponse> {
        let url_ = this.baseUrl + "/api/v1/election/find?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFind(_response);
        });
    }

    protected processFind(response: Response): Promise<ElectionQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ElectionQueryResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ElectionQueryResponse>(<any>null);
    }

    /**
     * Open Election
     * @return Successful Response
     */
    open(election_id: string): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/election/open?";
        if (election_id === undefined || election_id === null)
            throw new Error("The parameter 'election_id' must be defined and cannot be null.");
        else
            url_ += "election_id=" + encodeURIComponent("" + election_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOpen(_response);
        });
    }

    protected processOpen(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }

    /**
     * Close Election
     * @return Successful Response
     */
    close(election_id: string): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/election/close?";
        if (election_id === undefined || election_id === null)
            throw new Error("The parameter 'election_id' must be defined and cannot be null.");
        else
            url_ += "election_id=" + encodeURIComponent("" + election_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClose(_response);
        });
    }

    protected processClose(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }

    /**
     * Publish Election
     * @return Successful Response
     */
    publish(election_id: string): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/election/publish?";
        if (election_id === undefined || election_id === null)
            throw new Error("The parameter 'election_id' must be defined and cannot be null.");
        else
            url_ += "election_id=" + encodeURIComponent("" + election_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }

    /**
     * Build Election Context
     * @return Successful Response
     */
    context(body: MakeElectionContextRequest): Promise<MakeElectionContextResponse> {
        let url_ = this.baseUrl + "/api/v1/election/context";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContext(_response);
        });
    }

    protected processContext(response: Response): Promise<MakeElectionContextResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MakeElectionContextResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MakeElectionContextResponse>(<any>null);
    }
}

export class ManifestClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Find Manifests
     * @param skip (optional) 
     * @param limit (optional) 
     * @return Successful Response
     */
    find(skip: number | undefined, limit: number | undefined, body: BaseQueryRequest): Promise<ManifestQueryResponse> {
        let url_ = this.baseUrl + "/api/v1/manifest/find?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFind(_response);
        });
    }

    protected processFind(response: Response): Promise<ManifestQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ManifestQueryResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ManifestQueryResponse>(<any>null);
    }

    /**
     * Validate Manifest
     * @return Successful Response
     */
    validate(body: ValidateManifestRequest): Promise<ValidateManifestResponse> {
        let url_ = this.baseUrl + "/api/v1/manifest/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidate(_response);
        });
    }

    protected processValidate(response: Response): Promise<ValidateManifestResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ValidateManifestResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValidateManifestResponse>(<any>null);
    }
}

export class BallotClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Fetch Ballot Inventory
     * @return Successful Response
     */
    inventory(election_id: string): Promise<BallotInventoryResponse> {
        let url_ = this.baseUrl + "/api/v1/ballot/inventory?";
        if (election_id === undefined || election_id === null)
            throw new Error("The parameter 'election_id' must be defined and cannot be null.");
        else
            url_ += "election_id=" + encodeURIComponent("" + election_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInventory(_response);
        });
    }

    protected processInventory(response: Response): Promise<BallotInventoryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BallotInventoryResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BallotInventoryResponse>(<any>null);
    }

    /**
     * Find Ballots
     * @param skip (optional) 
     * @param limit (optional) 
     * @return Successful Response
     */
    find(election_id: string, skip: number | undefined, limit: number | undefined, body: BaseQueryRequest): Promise<BallotQueryResponse> {
        let url_ = this.baseUrl + "/api/v1/ballot/find?";
        if (election_id === undefined || election_id === null)
            throw new Error("The parameter 'election_id' must be defined and cannot be null.");
        else
            url_ += "election_id=" + encodeURIComponent("" + election_id) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFind(_response);
        });
    }

    protected processFind(response: Response): Promise<BallotQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BallotQueryResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BallotQueryResponse>(<any>null);
    }

    /**
     * Cast Ballots
     * @param election_id (optional) 
     * @return Successful Response
     */
    cast(election_id: string | undefined, body: CastBallotsRequest): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/ballot/cast?";
        if (election_id === null)
            throw new Error("The parameter 'election_id' cannot be null.");
        else if (election_id !== undefined)
            url_ += "election_id=" + encodeURIComponent("" + election_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCast(_response);
        });
    }

    protected processCast(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            result202 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result202;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }

    /**
     * Spoil Ballots
     * @param election_id (optional) 
     * @return Successful Response
     */
    spoil(election_id: string | undefined, body: SpoilBallotsRequest): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/ballot/spoil?";
        if (election_id === null)
            throw new Error("The parameter 'election_id' cannot be null.");
        else if (election_id !== undefined)
            url_ += "election_id=" + encodeURIComponent("" + election_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSpoil(_response);
        });
    }

    protected processSpoil(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            result202 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result202;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }

    /**
     * Submit Ballots
     * @param election_id (optional) 
     * @return Successful Response
     */
    submit(election_id: string | undefined, body: SubmitBallotsRequest): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/ballot/submit?";
        if (election_id === null)
            throw new Error("The parameter 'election_id' cannot be null.");
        else if (election_id !== undefined)
            url_ += "election_id=" + encodeURIComponent("" + election_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubmit(_response);
        });
    }

    protected processSubmit(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            result202 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result202;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }

    /**
     * Validate Ballot
     * @return Successful Response
     */
    validate(body: ValidateBallotRequest): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/ballot/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidate(_response);
        });
    }

    protected processValidate(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }

    /**
     * Decrypt Ballots
     * @return Successful Response
     */
    decrypt(body: DecryptBallotsWithSharesRequest): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/ballot/decrypt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDecrypt(_response);
        });
    }

    protected processDecrypt(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * Encrypt Ballots
     * @return Successful Response
     */
    encrypt(body: EncryptBallotsRequest): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/ballot/encrypt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEncrypt(_response);
        });
    }

    protected processEncrypt(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }
}

export class TestClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Test Submit Ballot
     * @return Successful Response
     */
    submit_queue(body: SubmitBallotsRequest): Promise<any> {
        let url_ = this.baseUrl + "/api/v1/ballot/test/submit_queue";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubmit_queue(_response);
        });
    }

    protected processSubmit_queue(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            result202 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result202;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }
}

export class TallyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Find Ciphertext Tallies
     * @param skip (optional) 
     * @param limit (optional) 
     * @return Successful Response
     */
    find(election_id: string, skip: number | undefined, limit: number | undefined, body: BaseQueryRequest): Promise<CiphertextTallyQueryResponse> {
        let url_ = this.baseUrl + "/api/v1/tally/find?";
        if (election_id === undefined || election_id === null)
            throw new Error("The parameter 'election_id' must be defined and cannot be null.");
        else
            url_ += "election_id=" + encodeURIComponent("" + election_id) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFind(_response);
        });
    }

    protected processFind(response: Response): Promise<CiphertextTallyQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CiphertextTallyQueryResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CiphertextTallyQueryResponse>(<any>null);
    }

    /**
     * Fetch Decryption Share
     * @return Successful Response
     */
    decryptGet(election_id: string, tally_name: string, guardian_id: string): Promise<DecryptionShareResponse> {
        let url_ = this.baseUrl + "/api/v1/tally/decrypt?";
        if (election_id === undefined || election_id === null)
            throw new Error("The parameter 'election_id' must be defined and cannot be null.");
        else
            url_ += "election_id=" + encodeURIComponent("" + election_id) + "&";
        if (tally_name === undefined || tally_name === null)
            throw new Error("The parameter 'tally_name' must be defined and cannot be null.");
        else
            url_ += "tally_name=" + encodeURIComponent("" + tally_name) + "&";
        if (guardian_id === undefined || guardian_id === null)
            throw new Error("The parameter 'guardian_id' must be defined and cannot be null.");
        else
            url_ += "guardian_id=" + encodeURIComponent("" + guardian_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDecryptGet(_response);
        });
    }

    protected processDecryptGet(response: Response): Promise<DecryptionShareResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DecryptionShareResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DecryptionShareResponse>(<any>null);
    }

    /**
     * Decrypt Tally
     * @param restart (optional) 
     * @return Successful Response
     */
    decryptPost(restart: boolean | undefined, body: DecryptTallyRequest): Promise<PlaintextTallyQueryResponse> {
        let url_ = this.baseUrl + "/api/v1/tally/decrypt?";
        if (restart === null)
            throw new Error("The parameter 'restart' cannot be null.");
        else if (restart !== undefined)
            url_ += "restart=" + encodeURIComponent("" + restart) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDecryptPost(_response);
        });
    }

    protected processDecryptPost(response: Response): Promise<PlaintextTallyQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PlaintextTallyQueryResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlaintextTallyQueryResponse>(<any>null);
    }
}

export class DecryptClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Submit Share
     * @return Successful Response
     */
    submitShare(body: DecryptionShareRequest): Promise<App__api__v1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1/tally/decrypt/submit-share";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubmitShare(_response);
        });
    }

    protected processSubmitShare(response: Response): Promise<App__api__v1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App__api__v1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1__models__base__BaseResponse>(<any>null);
    }

    /**
     * Find Decryption Shares
     * @param skip (optional) 
     * @param limit (optional) 
     * @return Successful Response
     */
    find(tally_name: string, skip: number | undefined, limit: number | undefined, body: BaseQueryRequest): Promise<DecryptionShareResponse> {
        let url_ = this.baseUrl + "/api/v1/tally/decrypt/find?";
        if (tally_name === undefined || tally_name === null)
            throw new Error("The parameter 'tally_name' must be defined and cannot be null.");
        else
            url_ += "tally_name=" + encodeURIComponent("" + tally_name) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFind(_response);
        });
    }

    protected processFind(response: Response): Promise<DecryptionShareResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DecryptionShareResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DecryptionShareResponse>(<any>null);
    }
}

export class V1_1Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Create Election
     * @return Successful Response
     */
    election(body: CreateElectionRequest): Promise<App__api__v1_1__models__base__BaseResponse> {
        let url_ = this.baseUrl + "/api/v1_1/election";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processElection(_response);
        });
    }

    protected processElection(response: Response): Promise<App__api__v1_1__models__base__BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App__api__v1_1__models__base__BaseResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : <HTTPValidationError>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<App__api__v1_1__models__base__BaseResponse>(<any>null);
    }

    /**
     * Ping
     * @return Successful Response
     */
    ping(): Promise<string> {
        let url_ = this.baseUrl + "/api/v1_1/ping";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPing(_response);
        });
    }

    protected processPing(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }
}

/** An enumeration. */
export enum ApiMode {
    Guardian = "guardian",
    Mediator = "mediator",
}

/** The Ballot Inventory retains metadata about ballots in an election, including mappings of ballot tracking codes to ballot id's */
export interface BallotInventory {
    election_id: string;
    cast_ballot_count?: number;
    spoiled_ballot_count?: number;
    cast_ballots?: { [key: string]: string; };
    spoiled_ballots?: { [key: string]: string; };
}

/** A basic response */
export interface BallotInventoryResponse {
    status?: App__api__v1__models__base__ResponseStatus;
    message?: string;
    inventory: BallotInventory;
}

/** A basic response */
export interface BallotQueryResponse {
    status?: App__api__v1__models__base__ResponseStatus;
    message?: string;
    election_id: string;
    ballots?: any[];
}

/** Find something */
export interface BaseQueryRequest {
    filter?: any;
}

export interface Body_create_user_api_v1_user_create_post {
    user_info: UserInfo;
    settings?: Settings;
}

export interface Body_login_for_access_token_api_v1_auth_login_post {
    grant_type?: string;
    username: string;
    password: string;
    scope?: string;
    client_id?: string;
    client_secret?: string;
}

/** Cast the enclosed ballots. */
export interface CastBallotsRequest {
    election_id?: string;
    manifest?: any;
    context?: CiphertextElectionContext;
    ballots: any[];
}

/** The meta-data required for an election including keys, manifest, number of guardians, and quorum */
export interface CiphertextElectionContext {
    number_of_guardians: number;
    quorum: number;
    elgamal_public_key: string;
    commitment_hash: string;
    manifest_hash: string;
    crypto_base_hash: string;
    crypto_extended_base_hash: string;
}

/** A Tally for a specific election. */
export interface CiphertextTally {
    election_id: string;
    tally_name: string;
    created: Date;
    tally?: any;
}

/** A DecryptionShare provided by a guardian for a specific tally. Optionally can include ballot_shares for challenge ballots. */
export interface CiphertextTallyDecryptionShare {
    election_id: string;
    tally_name: string;
    guardian_id: string;
    tally_share?: any;
    ballot_shares?: any;
}

/** A collection of Ciphertext Tallies. */
export interface CiphertextTallyQueryResponse {
    status?: App__api__v1__models__base__ResponseStatus;
    message?: string;
    tallies?: CiphertextTally[];
}

/** Create an election. */
export interface CreateElectionRequest {
    name: string;
}

/** Decrypt the provided ballots with the provided shares */
export interface DecryptBallotsWithSharesRequest {
    encrypted_ballots: any[];
    shares: { [key: string]: any[]; };
    context: CiphertextElectionContext;
}

/** A request to decrypt a specific tally.  Can optionally include the tally to decrypt. */
export interface DecryptTallyRequest {
    election_id: string;
    tally_name: string;
}

/** A request to submit a decryption share. */
export interface DecryptionShareRequest {
    share: CiphertextTallyDecryptionShare;
}

/** A response that includes a collection of decryption shares. */
export interface DecryptionShareResponse {
    status?: App__api__v1__models__base__ResponseStatus;
    message?: string;
    shares: CiphertextTallyDecryptionShare[];
}

/** An election object. */
export interface Election {
    election_id: string;
    key_name: string;
    state: ElectionState;
    context: CiphertextElectionContext;
    manifest?: any;
}

/** Response object containing the Election Joint Key. */
export interface ElectionJointKeyResponse {
    status?: App__api__v1__models__base__ResponseStatus;
    message?: string;
    elgamal_public_key?: any;
    commitment_hash?: any;
}

/** A request for elections using the specified filter. */
export interface ElectionQueryRequest {
    filter?: any;
}

/** A collection of elections. */
export interface ElectionQueryResponse {
    status?: App__api__v1__models__base__ResponseStatus;
    message?: string;
    elections?: Election[];
}

/** An enumeration. */
export enum ElectionState {
    CREATED = "CREATED",
    OPEN = "OPEN",
    CLOSED = "CLOSED",
    PUBLISHED = "PUBLISHED",
}

/** A request to encrypt the enclosed ballots. */
export interface EncryptBallotsRequest {
    election_id: string;
    seed_hash: string;
    ballots: any[];
}

/** Returns error messages to the client. */
export interface ErrorMessage {
    detail: string;
}

/** A set of public auxiliary and election keys. */
export interface GuardianAnnounceRequest {
    key_name: string;
    public_keys?: any;
}

/** Returns a collection of KeyCeremonyGuardians. */
export interface GuardianQueryResponse {
    status?: App__api__v1__models__base__ResponseStatus;
    message?: string;
    guardians: KeyCeremonyGuardian[];
}

/** Submit a collection of backups for a guardian. */
export interface GuardianSubmitBackupRequest {
    key_name: string;
    guardian_id: string;
    backups: any[];
}

/** Submit a collection of challenges for a guardian. */
export interface GuardianSubmitChallengeRequest {
    key_name: string;
    guardian_id: string;
    challenges: any[];
}

/** Submit a collection of verifications for a guardian. */
export interface GuardianSubmitVerificationRequest {
    key_name: string;
    guardian_id: string;
    verifications: any[];
}

export interface HTTPValidationError {
    detail?: ValidationError[];
}

/** The Key Ceremony is a record of the state of a key ceremony. */
export interface KeyCeremony {
    key_name: string;
    state: KeyCeremonyState;
    number_of_guardians: number;
    quorum: number;
    guardian_ids: string[];
    guardian_status: { [key: string]: KeyCeremonyGuardianState; };
    elgamal_public_key?: any;
    commitment_hash?: any;
}

/** Request to create a new key ceremony. */
export interface KeyCeremonyCreateRequest {
    key_name: string;
    number_of_guardians: number;
    quorum: number;
    guardian_ids: string[];
}

/** A record of the public data exchanged between guardians. */
export interface KeyCeremonyGuardian {
    key_name: string;
    guardian_id: string;
    name: string;
    sequence_order: number;
    number_of_guardians: number;
    quorum: number;
    public_keys?: any;
    backups?: any[];
    verifications?: any[];
    challenges?: any[];
}

/** Describes the operations each guardian must fulfill to complete a key ceremony. */
export interface KeyCeremonyGuardianState {
    public_key_shared?: KeyCeremonyGuardianStatus;
    backups_shared?: KeyCeremonyGuardianStatus;
    backups_verified?: KeyCeremonyGuardianStatus;
}

/** Enumeration expressing the status of a guardian's operations. */
export enum KeyCeremonyGuardianStatus {
    INCOMPLETE = "INCOMPLETE",
    ERROR = "ERROR",
    COMPLETE = "COMPLETE",
}

/** Returns a collection of Key Ceremonies. */
export interface KeyCeremonyQueryResponse {
    status?: App__api__v1__models__base__ResponseStatus;
    message?: string;
    key_ceremonies: KeyCeremony[];
}

/** Enumeration expressing the state of the key caremony. */
export enum KeyCeremonyState {
    CREATED = "CREATED",
    OPEN = "OPEN",
    CLOSED = "CLOSED",
    CHALLENGED = "CHALLENGED",
    CANCELLED = "CANCELLED",
}

/** Returns a subset of KeyCeremony data that describes only the state. */
export interface KeyCeremonyStateResponse {
    key_name: string;
    state: KeyCeremonyState;
    guardian_status: { [key: string]: KeyCeremonyGuardianState; };
}

/** A request to build an Election Context for a given election. */
export interface MakeElectionContextRequest {
    elgamal_public_key: string;
    commitment_hash: string;
    number_of_guardians: number;
    quorum: number;
    manifest_hash?: string;
    manifest?: any;
}

/** A Ciphertext Election Context. */
export interface MakeElectionContextResponse {
    status?: App__api__v1__models__base__ResponseStatus;
    message?: string;
    context: CiphertextElectionContext;
}

/** A basic model object */
export interface Manifest {
    manifest_hash?: any;
    manifest?: any;
}

/** A basic response */
export interface ManifestQueryResponse {
    status?: App__api__v1__models__base__ResponseStatus;
    message?: string;
    manifests: Manifest[];
}

/** A basic response */
export interface ManifestSubmitResponse {
    status?: App__api__v1__models__base__ResponseStatus;
    message?: string;
    manifest_hash?: any;
}

/** A plaintext tally for a specific election. */
export interface PlaintextTally {
    election_id: string;
    tally_name: string;
    created: Date;
    state: PlaintextTallyState;
    tally?: any;
}

/** A collection of Plaintext Tallies. */
export interface PlaintextTallyQueryResponse {
    status?: App__api__v1__models__base__ResponseStatus;
    message?: string;
    tallies?: PlaintextTally[];
}

/** An enumeration. */
export enum PlaintextTallyState {
    CREATED = "CREATED",
    PROCESSING = "PROCESSING",
    ERROR = "ERROR",
    COMPLETE = "COMPLETE",
}

/** Request to publish the election joint key. */
export interface PublishElectionJointKeyRequest {
    key_name: string;
    election_public_keys: any[];
}

/** An enumeration. */
export enum QueueMode {
    Local = "local",
    Remote = "remote",
}

/** Base class for settings, allowing values to be overridden by environment variables. This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose), Heroku and any 12 factor app design. */
export interface Settings {
    API_MODE?: ApiMode;
    QUEUE_MODE?: QueueMode;
    STORAGE_MODE?: StorageMode;
    API_V1_STR?: string;
    API_V1_1_STR?: string;
    BACKEND_CORS_ORIGINS?: string[];
    PROJECT_NAME?: string;
    MONGODB_URI?: string;
    MESSAGEQUEUE_URI?: string;
    AUTH_ALGORITHM?: string;
    AUTH_SECRET_KEY?: string;
    AUTH_ACCESS_TOKEN_EXPIRE_MINUTES?: number;
    DEFAULT_ADMIN_USERNAME?: string;
    DEFAULT_ADMIN_PASSWORD?: string;
}

/** Spoil the enclosed ballots. */
export interface SpoilBallotsRequest {
    election_id?: string;
    manifest?: any;
    context?: CiphertextElectionContext;
    ballots: any[];
}

/** An enumeration. */
export enum StorageMode {
    Local_storage = "local_storage",
    Mongo = "mongo",
}

/** Submit a ballot against a specific election. */
export interface SubmitBallotsRequest {
    election_id?: string;
    manifest?: any;
    context?: CiphertextElectionContext;
    ballots: any[];
}

/** Submit an election. */
export interface SubmitElectionRequest {
    election_id: string;
    key_name: string;
    context: CiphertextElectionContext;
    manifest?: any;
}

/** An access token and its type. */
export interface Token {
    access_token: string;
    token_type: string;
}

/** A specific user in the system */
export interface UserInfo {
    username: string;
    scopes?: UserScope[];
    email?: string;
    disabled?: boolean;
}

/** An enumeration. */
export enum UserScope {
    Admin = "admin",
    Auditor = "auditor",
    Guardian = "guardian",
    Voter = "voter",
}

/** Submit a ballot against a specific election description and contest to determine if it is accepted. */
export interface ValidateBallotRequest {
    schema_override?: any;
    ballot?: any;
    manifest?: any;
    context: CiphertextElectionContext;
}

/** A request to validate an Election Description. */
export interface ValidateManifestRequest {
    schema_override?: any;
    manifest?: any;
}

/** Response for validating models */
export interface ValidateManifestResponse {
    status?: App__api__v1__models__base__ResponseStatus;
    message?: string;
    details?: string;
    manifest_hash?: string;
}

export interface ValidationError {
    loc: string[];
    msg: string;
    type: string;
}

/** A basic response */
export interface App__api__v1_1__models__base__BaseResponse {
    status?: App__api__v1_1__models__base__ResponseStatus;
    message?: string;
}

/** An enumeration. */
export enum App__api__v1_1__models__base__ResponseStatus {
    Fail = "fail",
    Success = "success",
}

/** A basic response */
export interface App__api__v1__models__base__BaseResponse {
    status?: App__api__v1__models__base__ResponseStatus;
    message?: string;
}

/** An enumeration. */
export enum App__api__v1__models__base__ResponseStatus {
    Fail = "fail",
    Success = "success",
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}